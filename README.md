# rotate-matrix-example
Как-то я проходил собеседование в одну компанию. Мне задали задачу: перевернуть матрицу.
```
// Дано:
const data = [
    [1, 2, 3, 4, 5],
    [6, 7, 8, 9, 10],
    [11, 12, 13, 14, 5],
  ];

// Ожидается получить на выходе:
const expected = [
    [1, 6, 11],
    [2, 7, 12],
    [3, 8, 13],
    [4, 9, 14],
    [5, 10, 15]
  ];
```
Сначала хотел решить с помощью методов массива, но в виду волнительности момента - застрял короче на пути к решению.
Задача была решина с помощью цикла `for`, но после собеседования я все-таки хоте довести до конца свое решение с помощью методов,
и параллельно сравнить их быстродействие.

# Шаг за шагом:
***1. Предусловия***<br />
***2. Генерация матрицы***<br />
***3. Переворачиваем матрицу***<br />

# Предусловия
1. Нам нужна функция, которая будет принимает 2 аргумента: число строк и столбцов. <br />
2. Поскольку реализаций функции которая генерирует матрицу получилось очень много, я приведу код основных 4-х вариантов, а о вариациях лишь упомяну вскольз.
3. Все функции я запускал по нескольку раз, и старался больше определить тенденции, а не конкретные цифры. В ваших условиях результаты могут отличаться.
4. Ubuntu 16 64-bit, Chrome 75.0.3770.142 64 bit, Core i7-8750H, порядка 40 открытых вкладок Хрома и VS Code в фоне.
5. Матрицу решил взять 10К * 10К чисел. Возможно ваш браузер сожрет всю память(!) и комп будет тупить, а возможно тайминг окажется быстрее.

*// We are good to go*

# Генерация матрицы
По условию задачи исходный массив был уже дан, но в нашем случае мы сгенерируем его. Пусть это будет функция, которая принемает 2 аргумента (число строк и столбцов).

Первое, что пришло в голову &mdash; вложенные циклы, создание промежуточных массивов и заполнение с помощью `push`.

```
// 1298 ms
function generateMatrix(k = 10, n = 10) {
  const result = [];
  for (var i = 0, counter = 1; i < n; i++) {
    const newArr = [];
    for (var j = 0; j < k; j++) {
      newArr.push(counter);
      counter++;
    }
    result.push(newArr);
  }
  return result;
};
```

Затем я подумал: а повлияет ли способ создания массива?
```
// 1567 ms
function generateMatrix3(k = 10, n = 10) {
  const result = new Array(0);
  for (var i = 0, counter = 1; i < n; i++) {
    const newArr = new Array(0);
    for (var j = 0; j < k; j++) {
      newArr.push(counter);
      counter++;
    }
    result.push(newArr);
  }
  return result;
};
```
Немножко медленнее. При чем, есть 2 варианта: мы можем создавать массив как `new Array()`, так и прокидывать в конструктор число, которое будет длинной массива. Во втором случае код работает немного быстрее.

Хорошо, а если мы попробуем избежать метода `push`, а сохранить значение через присваивание, что будет?

```
// 1520 ms
function generateMatrix4(k = 10, n = 10) {
  const result = [];
  for (var i = 0, counter = 1; i < n; i++) {
    const newArr = [];
    for (var j = 0; j < k; j++) {
      newArr[j] = counter;
      counter++;
    }
    result[i] = newArr;
  }
  return result;
};
```
Метод `push()` добавляет один или более элементов в конец массива и возвращает новую длину массива. (Источник: MDN)
Нам по сути возвращаемое значение не нужно, мы нигде его не храним, видимо по этому код работает чуточку быстрее.

Хорошо, раз вариант, когда в конструктор мы прокидываем длинну массива работает чуток быстрее, что же будет, если мы сразу создадим оба массива нужной длинны?
А вот что:

```
// 937 ms
function generateMatrix7(k = 10, n = 10) {
  const result = new Array(n);
  for (var i = 0, counter = 1; i < n; i++) {
    const newArr = new Array(k);
    for (var j = 0; j < k; j++) {
      newArr[j] = counter;
      counter++;
    }
    result[i] = newArr;
  }
  return result;
};
```
Где-то в вумных книгах читал, что если создаем массив фиксированной длинны, сразу под него выделяется вся необходимая память. И при расширении массива компилятору необходимо искать память большей длинны и туда перемещать весь массив целиком. Короче, каждый раз расширять массив - дорого.

Все как бы ничего, но мы до этого постоянно использовали вложенный цикл. Можем ли мы как-то переписать эту функцию так, чтобы один раз пройтись по массиву?
Ну допустим так:
```
// 1553 ms
function generateMatrix8(k = 10, n = 10) {
  let counter = 0, externalIndex = 0, tempArray; // (1)
  const total = k * n;
  const result = new Array(n);
  while(counter < total) {
    const index = counter % k;
    if (index === 0) { // (2)
      tempArray = new Array(k);
    }
    tempArray[index] = counter + 1;
    if((counter + 1 ) % k === 0) {
      result[externalIndex] = tempArray;
      externalIndex++;
                        // (3)
    }
    ++counter;
  }
  return result;
};
```

Сюрприз, сюрприз. Вроде бы цикл 1, но работает не так быстро как ожидалось.

И тут такие вариации:
1. Сравнение `==` и `===` работают с минимальным отличием по скорости. Может показаться что `==` будет работать быстрее, т.к. не происходит проверка типов, но разница очень не существенна. Чаще с `===` на какие-то доли секунд отрабатывает быстрее.
2. Очень смущает дополнительная проверка (2). Хотелось бы от нее избавиться. Если в задавать значение по умолчанию в (1) и в (3) пересоздавать массив?
3. Что с `tempArray = []`, что с `tempArray = new Array(k)` быстрее работать не будет. По скольку массив ссылочный тип, мы можем либо записать ссылку на новый массив из другого участка памяти, либо создать новый массив. Такая бы штука прокатила с примитивами, но с сылочными типами - увы.
4. А если создавать новый объект, на сколько это будет долго (для 10К числел)?

И тут мне захотелось посмотреть, что же все таки быстрее: `(...)` оператор, или старый добрый Object.assign?

```
// 2060 ms
function generateMatrix10(k = 10, n = 10) {
  var counter = 0, externalIndex = 0, tempArray = new Array(k);
  const total = k * n;
  const result = new Array(n);
  while(counter < total) {
    const index = counter % k;
    tempArray[index] = counter + 1;
    if((counter + 1) % k === 0) {
      result[externalIndex] = [...tempArray];
      externalIndex++;
    }
    ++counter;
  }
  return result;
};
```
Мда, оптимизацией тут явно не пахнет. Ну может `Object.assign` поможет. Все таки еще до спред оператора работал с ним. Давай, братуха, я в тебя верю.

```
// 23036 ms
function generateMatrix11(k = 10, n = 10) {
  var counter = 0, externalIndex = 0, tempArray = new Array(k);
  const total = k * n;
  const result = new Array(n);
  while(counter < total) {
    const index = counter % k;
    tempArray[index] = counter + 1;
    if((counter + 1) % k === 0) {
      result[externalIndex] = Object.assign([], tempArray);
      externalIndex++;
    }
    ++counter;
  }
  return result;
};
```

- Эм ... ты там живой?
- ...
- Че так долго?
- ...
- О, куллер зашумел. Теплее как-то стало.
- ... Done!
- Сколько, Сколько? 23 секунды? Че так долго?.

Честно говоря, я такого результата вообще не ожидал. По по ходу возник новый топик для изучения: как на самом деле работает `Object.assign` и `(...)` оператор.

Ладно погнали дальше. Чё там у нас? Ах да, чуть не забыл. Можем матрицу заполнить еще и методами перебора массивов. 
```
// 2027 ms
function generateMatrix12(k = 10, n = 10) {
  let counter = 1;
  return new Array(n).fill(0)
    .map((inner, i) =>
      inner[i] = new Array(k).fill(0)
        .map(outer => outer = counter++)
    );
};
```
И тут, по скольку перебрать массив с `[empty × 10000]` мы не можем, к сожалению приходиться его предварительно заполнять нулями.

# Переворачиваем матрицу
Начнем с функции которую написал на тех. интервью. А для генерации массива будем использовать `generateMatrix7`, т.к. она самая быстрая.

```
const matrix = generateMatrix7(10000, 10000);
console.log('matrix prepered', matrix.length);

console.time('methods');
rotateArrayUsingForLoop(matrix)
console.timeEnd('methods');
```

И собственно наша функция:
```
// 7689 ms
function rotateArrayUsingForLoop(array) {
  const result = [];
  for (let i = 0; i < array.length; i++) {
    for (let j = 0; j < array[i].length; j++) {
      if(!result[j]) {
        result[j] = [];
      }
      result[j].push(array[i][j]);
    }
  }
  return result;
}
```
7 секунд. Да, штука не быстрая получилась. Интересно, как же получиться с методами?

```
// 1989 ms
function rotateArrayUsingMethods(array) {
  return array.reduce((result, subArray) =>
    subArray.map((elem, j) => {
      if(!result[j]) {
        result[j] = [];
      }
      result[j] = elem;
    }),
  new Array(array[0].length));
}
```
Ооо, вот это по лучше. Назревает вопрос, а нафига мне изучать цикл `for`, который сложный, морально устарел уже, и никто его не использует, и он медленный к тому же.

Но это только на первый взгляд. Немного оптимизации, и вуаля:
```
// 333 ms
function rotateArrayUsingForLoop2(array) {
  const result = new Array(array[0].length);
  const len = array.length;
  for (var i = 0; i < len; i++) {
    for (var j = 0, itemLen = array[i].length; j < itemLen; j++) {
      if(!result[j]) {
        result[j] = [array[i][j]];
        continue;
      }
      result[j] = array[i][j];
    }
  }
  return result;
}
```

Пушка-ракета! За что действительно я люблю старые добрые циклы - так это за возможность скипать итерацию на следующий шаг или прерывать выполнение цикла.

P.S. Возможно эта дилетантская статья когда-нибудь дорастет до уровня хабра (ну, когда я еще больше вникну в глубины JS и смогу объяснить что и как там под капотом), а пока вы можете насладиться чтивом которое меня вдохновило на поиски таких оптимизаций:
https://dou.ua/lenta/articles/why-understanding-algorithms-is-important/
https://habr.com/ru/company/otus/blog/547098/

P.P.S. Так же, когда есть массив объектов, и необходимо сделать поиск, очень классным решением нашел вот что:
```
const users = [
  {
    id: 1,
    name: 'Joe I',
    email: 'joe-1@mail.com'
  },
  {
    id: 2,
    name: 'Joe II',
    email: 'joe-2@mail.com'
  },
  {
    id: 3,
    name: 'Joe III',
    email: 'joe-3@mail.com'
  },
];

const obj = users.reduce((acc, cur) => {
  acc[cur.email] = cur;
  return acc;
}, {});

obj[user.email].name;
```
Лучше сделать один проход O(n) по всем элементам и преобразовать массив в объект, и найти данные за O(2n) или O(1), чем делать вложенные циклы в O(n^2);

